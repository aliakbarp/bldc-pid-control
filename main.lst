   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	__floatunsisf
  11               	.global	__mulsf3
  12               	.global	__addsf3
  13               	.global	__ltsf2
  14               	.global	__divsf3
  15               	.global	__subsf3
  16               	.global	__fixunssfsi
  17               		.section	.text.startup,"ax",@progbits
  18               	.global	main
  20               	main:
  21               	.LFB8:
  22               		.file 1 "main.c"
   1:main.c        **** /***********************************
   2:main.c        ****  * Main file of BLDC control system
   3:main.c        ****  * with PID
   4:main.c        ****  * 
   5:main.c        ****  * Created by aliakbarp
   6:main.c        ****  ***********************************/
   7:main.c        **** 
   8:main.c        **** #include <src/initlib.h> 
   9:main.c        **** 
  10:main.c        **** #define NEED_TIME_STAMP
  11:main.c        **** 
  12:main.c        **** int main(void){
  23               		.loc 1 12 0
  24               		.cfi_startproc
  25 0000 CF93      		push r28
  26               	.LCFI0:
  27               		.cfi_def_cfa_offset 3
  28               		.cfi_offset 28, -2
  29 0002 DF93      		push r29
  30               	.LCFI1:
  31               		.cfi_def_cfa_offset 4
  32               		.cfi_offset 29, -3
  33 0004 00D0      		rcall .
  34 0006 00D0      		rcall .
  35               	.LCFI2:
  36               		.cfi_def_cfa_offset 8
  37 0008 CDB7      		in r28,__SP_L__
  38 000a DEB7      		in r29,__SP_H__
  39               	.LCFI3:
  40               		.cfi_def_cfa_register 28
  41               	/* prologue: function */
  42               	/* frame size = 4 */
  43               	/* stack size = 6 */
  44               	.L__stack_usage = 6
  13:main.c        **** 	// disable global interrupt
  14:main.c        **** 	cli();
  45               		.loc 1 14 0
  46               	/* #APP */
  47               	 ;  14 "main.c" 1
  48 000c F894      		cli
  49               	 ;  0 "" 2
  15:main.c        **** 	timer_init();
  50               		.loc 1 15 0
  51               	/* #NOAPP */
  52 000e 0E94 0000 		call timer_init
  53               	.LVL0:
  16:main.c        **** 	lcd_init();
  54               		.loc 1 16 0
  55 0012 0E94 0000 		call lcd_init
  56               	.LVL1:
  17:main.c        **** 	bldc_init();
  57               		.loc 1 17 0
  58 0016 0E94 0000 		call bldc_init
  59               	.LVL2:
  18:main.c        **** 	uart_init( UART_BAUD_SELECT(UART_BAUD_RATE,F_CPU) ); 
  60               		.loc 1 18 0
  61 001a 87E6      		ldi r24,lo8(103)
  62 001c 90E0      		ldi r25,0
  63 001e 0E94 0000 		call uart_init
  64               	.LVL3:
  19:main.c        **** 	// enable global interrupt
  20:main.c        **** 	sei();
  65               		.loc 1 20 0
  66               	/* #APP */
  67               	 ;  20 "main.c" 1
  68 0022 7894      		sei
  69               	 ;  0 "" 2
  21:main.c        **** 	set_pid = true;
  70               		.loc 1 21 0
  71               	/* #NOAPP */
  72 0024 81E0      		ldi r24,lo8(1)
  73 0026 8093 0000 		sts set_pid,r24
  74               	.L6:
  22:main.c        **** 	while(1){
  23:main.c        **** 		// Getting data desired_rpm automatically
  24:main.c        **** 		// from UART RX interrupt
  25:main.c        **** 		
  26:main.c        **** 		//if(get_rawrpm){
  27:main.c        **** 		//	#if defined NEED_TIME_STAMP
  28:main.c        **** 				//timer2_temp = timer2_counting;
  29:main.c        **** 				//timer2_overflow_temp = timer2_overflow;
  30:main.c        **** 				// Get total counting for TIMER2
  31:main.c        **** 				//time_stamp = (double) timer2_overflow_temp * 256 + (double)timer2_temp;
  32:main.c        **** 				// convert TIMER2 count to millisecond
  33:main.c        **** 				//time_stamp = (double) time_stamp * 5E-4;	
  34:main.c        **** 				// Get millisecond based on calibration with ms reference
  35:main.c        **** 				//time_stamp = (double) 0.9531 * time_stamp + (double) 0.0187;			
  36:main.c        **** 				//serial_rpm(rpm, time_stamp);
  37:main.c        **** 		//	#endif
  38:main.c        **** 		//	get_rpm = true;
  39:main.c        **** 		//	get_rawrpm = false;
  40:main.c        **** 		//}
  41:main.c        **** 		
  42:main.c        **** 		//if(get_rpm){
  43:main.c        **** 			// get total counting for TIMER2
  44:main.c        **** 			//sampling_time = (double) timer2_overflow_temp * 256 + (double)timer2_temp;
  45:main.c        **** 			// convert TIMER2 count to millisecond, for each rotation
  46:main.c        **** 			//sampling_time = (double) sampling_time * 5E-4/(rotation_sampling);
  47:main.c        **** 			// Get millisecond based on calibration with ms reference
  48:main.c        **** 			//sampling_time = (double) 0.9531 * sampling_time + (double) 0.0187;
  49:main.c        **** 			//serial_display(sampling_time);
  50:main.c        **** 			//uart_putc(9);
  51:main.c        **** 			// convert to rpm
  52:main.c        **** 			//rpm = (double) 60E3/sampling_time;
  53:main.c        **** 			// Get hertz (1 rot = 4 Hz)
  54:main.c        **** 			//hertz = 4 * (rpm/60);
  55:main.c        **** 			// calibration factor
  56:main.c        **** 		//	set_pid = true;
  57:main.c        **** 		//	get_rpm = false;
  58:main.c        **** 		//}
  59:main.c        **** 		sampling_rate = 0;
  75               		.loc 1 59 0
  76 002a 1092 0000 		sts sampling_rate,__zero_reg__
  77 002e 1092 0000 		sts sampling_rate+1,__zero_reg__
  78 0032 1092 0000 		sts sampling_rate+2,__zero_reg__
  79 0036 1092 0000 		sts sampling_rate+3,__zero_reg__
  60:main.c        **** 		data_sampling_time = 0;
  80               		.loc 1 60 0
  81 003a 1092 0000 		sts data_sampling_time,__zero_reg__
  82 003e 1092 0000 		sts data_sampling_time+1,__zero_reg__
  83 0042 1092 0000 		sts data_sampling_time+2,__zero_reg__
  84 0046 1092 0000 		sts data_sampling_time+3,__zero_reg__
  61:main.c        **** 		timer0_counting = 0;
  85               		.loc 1 61 0
  86 004a 16BC      		out 0x26,__zero_reg__
  62:main.c        **** 		timer2_overflow = 0;
  87               		.loc 1 62 0
  88 004c 1092 0000 		sts timer2_overflow,__zero_reg__
  89 0050 1092 0000 		sts timer2_overflow+1,__zero_reg__
  90 0054 1092 0000 		sts timer2_overflow+2,__zero_reg__
  91 0058 1092 0000 		sts timer2_overflow+3,__zero_reg__
  63:main.c        **** 		timer2_counting = 0;
  92               		.loc 1 63 0
  93 005c 1092 B200 		sts 178,__zero_reg__
  94               	.L3:
  64:main.c        **** 		while((timer0_counting <= timer0_counting_limit)){};
  95               		.loc 1 64 0 discriminator 1
  96 0060 86B5      		in r24,0x26
  97 0062 8930      		cpi r24,lo8(9)
  98 0064 00F0      		brlo .L3
  65:main.c        **** 		timer2_temp = timer2_counting;
  99               		.loc 1 65 0
 100 0066 6091 B200 		lds r22,178
 101 006a 70E0      		ldi r23,0
 102 006c 80E0      		ldi r24,0
 103 006e 90E0      		ldi r25,0
 104 0070 0E94 0000 		call __floatunsisf
 105               	.LVL4:
 106 0074 6093 0000 		sts timer2_temp,r22
 107 0078 7093 0000 		sts timer2_temp+1,r23
 108 007c 8093 0000 		sts timer2_temp+2,r24
 109 0080 9093 0000 		sts timer2_temp+3,r25
  66:main.c        **** 		timer2_overflow_temp = timer2_overflow;
 110               		.loc 1 66 0
 111 0084 8091 0000 		lds r24,timer2_overflow
 112 0088 9091 0000 		lds r25,timer2_overflow+1
 113 008c A091 0000 		lds r26,timer2_overflow+2
 114 0090 B091 0000 		lds r27,timer2_overflow+3
 115 0094 8093 0000 		sts timer2_overflow_temp,r24
 116 0098 9093 0000 		sts timer2_overflow_temp+1,r25
 117 009c A093 0000 		sts timer2_overflow_temp+2,r26
 118 00a0 B093 0000 		sts timer2_overflow_temp+3,r27
 119               	.L4:
  67:main.c        **** 		while(sampling_rate <10){
 120               		.loc 1 67 0 discriminator 1
 121 00a4 20E0      		ldi r18,0
 122 00a6 30E0      		ldi r19,0
 123 00a8 40E2      		ldi r20,lo8(32)
 124 00aa 51E4      		ldi r21,lo8(65)
 125 00ac 6091 0000 		lds r22,sampling_rate
 126 00b0 7091 0000 		lds r23,sampling_rate+1
 127 00b4 8091 0000 		lds r24,sampling_rate+2
 128 00b8 9091 0000 		lds r25,sampling_rate+3
 129 00bc 0E94 0000 		call __ltsf2
 130               	.LVL5:
 131 00c0 87FF      		sbrs r24,7
 132 00c2 00C0      		rjmp .L8
  68:main.c        **** 			sampling_rate = (double) timer2_overflow * 256 + (double)timer2_counting;
 133               		.loc 1 68 0
 134 00c4 1091 B200 		lds r17,178
 135 00c8 20E0      		ldi r18,0
 136 00ca 30E0      		ldi r19,0
 137 00cc 40E8      		ldi r20,lo8(-128)
 138 00ce 53E4      		ldi r21,lo8(67)
 139 00d0 6091 0000 		lds r22,timer2_overflow
 140 00d4 7091 0000 		lds r23,timer2_overflow+1
 141 00d8 8091 0000 		lds r24,timer2_overflow+2
 142 00dc 9091 0000 		lds r25,timer2_overflow+3
 143 00e0 0E94 0000 		call __mulsf3
 144               	.LVL6:
 145 00e4 6B01      		movw r12,r22
 146 00e6 7C01      		movw r14,r24
 147 00e8 612F      		mov r22,r17
 148 00ea 70E0      		ldi r23,0
 149 00ec 80E0      		ldi r24,0
 150 00ee 90E0      		ldi r25,0
 151 00f0 0E94 0000 		call __floatunsisf
 152               	.LVL7:
 153 00f4 9B01      		movw r18,r22
 154 00f6 AC01      		movw r20,r24
 155 00f8 C701      		movw r24,r14
 156 00fa B601      		movw r22,r12
 157 00fc 0E94 0000 		call __addsf3
 158               	.LVL8:
  69:main.c        **** 			sampling_rate = (double) sampling_rate * 5E-4/(rotation_sampling);
 159               		.loc 1 69 0
 160 0100 2FE6      		ldi r18,lo8(111)
 161 0102 32E1      		ldi r19,lo8(18)
 162 0104 43E0      		ldi r20,lo8(3)
 163 0106 5AE3      		ldi r21,lo8(58)
 164 0108 0E94 0000 		call __mulsf3
 165               	.LVL9:
 166 010c 20E0      		ldi r18,0
 167 010e 30E0      		ldi r19,0
 168 0110 40E0      		ldi r20,0
 169 0112 5FE3      		ldi r21,lo8(63)
 170 0114 0E94 0000 		call __mulsf3
 171               	.LVL10:
  70:main.c        **** 			sampling_rate = (double) 0.9531 * sampling_rate + (double) 0.0187;
 172               		.loc 1 70 0
 173 0118 2DE5      		ldi r18,lo8(93)
 174 011a 3EEF      		ldi r19,lo8(-2)
 175 011c 43E7      		ldi r20,lo8(115)
 176 011e 5FE3      		ldi r21,lo8(63)
 177 0120 0E94 0000 		call __mulsf3
 178               	.LVL11:
 179 0124 2EEB      		ldi r18,lo8(-66)
 180 0126 30E3      		ldi r19,lo8(48)
 181 0128 49E9      		ldi r20,lo8(-103)
 182 012a 5CE3      		ldi r21,lo8(60)
 183 012c 0E94 0000 		call __addsf3
 184               	.LVL12:
 185 0130 6093 0000 		sts sampling_rate,r22
 186 0134 7093 0000 		sts sampling_rate+1,r23
 187 0138 8093 0000 		sts sampling_rate+2,r24
 188 013c 9093 0000 		sts sampling_rate+3,r25
 189               	.LVL13:
 190               	.LBB4:
 191               	.LBB5:
 192               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/lib/avr/include/util/delay.h **** 
 153:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/lib/avr/include/util/delay.h **** 
 156:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/lib/avr/include/util/delay.h **** 
 159:/usr/lib/avr/include/util/delay.h **** 	#else
 160:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 161:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/lib/avr/include/util/delay.h **** 	#endif
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 165:/usr/lib/avr/include/util/delay.h **** 
 166:/usr/lib/avr/include/util/delay.h **** #else
 167:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/lib/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/lib/avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/lib/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/lib/avr/include/util/delay.h **** 	{
 172:/usr/lib/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/lib/avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/lib/avr/include/util/delay.h **** 		{
 176:/usr/lib/avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/lib/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/lib/avr/include/util/delay.h **** 			__ticks --;
 179:/usr/lib/avr/include/util/delay.h **** 		}
 180:/usr/lib/avr/include/util/delay.h **** 		return;
 181:/usr/lib/avr/include/util/delay.h **** 	}
 182:/usr/lib/avr/include/util/delay.h **** 	else
 183:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/lib/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/lib/avr/include/util/delay.h **** #endif
 186:/usr/lib/avr/include/util/delay.h **** }
 187:/usr/lib/avr/include/util/delay.h **** 
 188:/usr/lib/avr/include/util/delay.h **** /**
 189:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/lib/avr/include/util/delay.h **** 
 191:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/lib/avr/include/util/delay.h **** 
 193:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/lib/avr/include/util/delay.h **** 
 196:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/lib/avr/include/util/delay.h **** 
 198:/usr/lib/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/lib/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/lib/avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/lib/avr/include/util/delay.h **** 
 202:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/lib/avr/include/util/delay.h ****   
 207:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/lib/avr/include/util/delay.h **** 
 211:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/lib/avr/include/util/delay.h ****  
 214:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/lib/avr/include/util/delay.h **** 
 222:/usr/lib/avr/include/util/delay.h ****  */
 223:/usr/lib/avr/include/util/delay.h **** void
 224:/usr/lib/avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/lib/avr/include/util/delay.h **** {
 226:/usr/lib/avr/include/util/delay.h **** 	uint8_t __ticks;
 227:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 228:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 229:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 230:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 231:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 232:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 233:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 234:/usr/lib/avr/include/util/delay.h **** 
 235:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 236:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 237:/usr/lib/avr/include/util/delay.h **** 
 238:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 239:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 240:/usr/lib/avr/include/util/delay.h **** 
 241:/usr/lib/avr/include/util/delay.h **** 	#else
 242:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 243:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 244:/usr/lib/avr/include/util/delay.h **** 	#endif
 245:/usr/lib/avr/include/util/delay.h **** 
 246:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 193               		.loc 2 246 0
 194 0140 85E0      		ldi r24,lo8(5)
 195 0142 8A95      		1: dec r24
 196 0144 01F4      		brne 1b
 197 0146 0000      		nop
 198 0148 00C0      		rjmp .L4
 199               	.LVL14:
 200               	.L8:
 201               	.LBE5:
 202               	.LBE4:
  71:main.c        **** 			_delay_us(1);
  72:main.c        **** 			//serial_display(timer2_overflow);
  73:main.c        **** 			//uart_putc(10);
  74:main.c        **** 		}	
  75:main.c        **** 		// get total counting for TIMER2
  76:main.c        **** 		data_sampling_time = (double) timer2_overflow_temp * 256 + (double)timer2_temp;
 203               		.loc 1 76 0
 204 014a 20E0      		ldi r18,0
 205 014c 30E0      		ldi r19,0
 206 014e 40E8      		ldi r20,lo8(-128)
 207 0150 53E4      		ldi r21,lo8(67)
 208 0152 6091 0000 		lds r22,timer2_overflow_temp
 209 0156 7091 0000 		lds r23,timer2_overflow_temp+1
 210 015a 8091 0000 		lds r24,timer2_overflow_temp+2
 211 015e 9091 0000 		lds r25,timer2_overflow_temp+3
 212 0162 0E94 0000 		call __mulsf3
 213               	.LVL15:
 214 0166 2091 0000 		lds r18,timer2_temp
 215 016a 3091 0000 		lds r19,timer2_temp+1
 216 016e 4091 0000 		lds r20,timer2_temp+2
 217 0172 5091 0000 		lds r21,timer2_temp+3
 218 0176 0E94 0000 		call __addsf3
 219               	.LVL16:
  77:main.c        **** 		// convert TIMER2 count to millisecond, for each rotation
  78:main.c        **** 		data_sampling_time = (double) data_sampling_time * 5E-4/(rotation_sampling);
 220               		.loc 1 78 0
 221 017a 2FE6      		ldi r18,lo8(111)
 222 017c 32E1      		ldi r19,lo8(18)
 223 017e 43E0      		ldi r20,lo8(3)
 224 0180 5AE3      		ldi r21,lo8(58)
 225 0182 0E94 0000 		call __mulsf3
 226               	.LVL17:
 227 0186 20E0      		ldi r18,0
 228 0188 30E0      		ldi r19,0
 229 018a 40E0      		ldi r20,0
 230 018c 5FE3      		ldi r21,lo8(63)
 231 018e 0E94 0000 		call __mulsf3
 232               	.LVL18:
  79:main.c        **** 		// Get millisecond based on calibration with ms reference
  80:main.c        **** 		data_sampling_time = (double) 0.9531 * data_sampling_time + (double) 0.0187;
 233               		.loc 1 80 0
 234 0192 2DE5      		ldi r18,lo8(93)
 235 0194 3EEF      		ldi r19,lo8(-2)
 236 0196 43E7      		ldi r20,lo8(115)
 237 0198 5FE3      		ldi r21,lo8(63)
 238 019a 0E94 0000 		call __mulsf3
 239               	.LVL19:
 240 019e 2EEB      		ldi r18,lo8(-66)
 241 01a0 30E3      		ldi r19,lo8(48)
 242 01a2 49E9      		ldi r20,lo8(-103)
 243 01a4 5CE3      		ldi r21,lo8(60)
 244 01a6 0E94 0000 		call __addsf3
 245               	.LVL20:
 246 01aa 9B01      		movw r18,r22
 247 01ac AC01      		movw r20,r24
 248 01ae 6093 0000 		sts data_sampling_time,r22
 249 01b2 7093 0000 		sts data_sampling_time+1,r23
 250 01b6 8093 0000 		sts data_sampling_time+2,r24
 251 01ba 9093 0000 		sts data_sampling_time+3,r25
  81:main.c        **** 		
  82:main.c        **** 		//serial_display(sampling_rate);
  83:main.c        **** 		//uart_putc(9);
  84:main.c        **** 		
  85:main.c        **** 		// convert to rpm
  86:main.c        **** 		rpm = (double) 60E3/data_sampling_time;
 252               		.loc 1 86 0
 253 01be 60E0      		ldi r22,0
 254 01c0 70E6      		ldi r23,lo8(96)
 255 01c2 8AE6      		ldi r24,lo8(106)
 256 01c4 97E4      		ldi r25,lo8(71)
 257 01c6 0E94 0000 		call __divsf3
 258               	.LVL21:
 259 01ca 6B01      		movw r12,r22
 260 01cc 7C01      		movw r14,r24
 261 01ce 6093 0000 		sts rpm,r22
 262 01d2 7093 0000 		sts rpm+1,r23
 263 01d6 8093 0000 		sts rpm+2,r24
 264 01da 9093 0000 		sts rpm+3,r25
  87:main.c        **** 		// Get hertz (1 rot = 4 Hz)
  88:main.c        **** 		hertz = 4 * (rpm/60);
 265               		.loc 1 88 0
 266 01de 20E0      		ldi r18,0
 267 01e0 30E0      		ldi r19,0
 268 01e2 40E7      		ldi r20,lo8(112)
 269 01e4 52E4      		ldi r21,lo8(66)
 270 01e6 0E94 0000 		call __divsf3
 271               	.LVL22:
 272 01ea 20E0      		ldi r18,0
 273 01ec 30E0      		ldi r19,0
 274 01ee 40E8      		ldi r20,lo8(-128)
 275 01f0 50E4      		ldi r21,lo8(64)
 276 01f2 0E94 0000 		call __mulsf3
 277               	.LVL23:
 278 01f6 6093 0000 		sts hertz,r22
 279 01fa 7093 0000 		sts hertz+1,r23
 280 01fe 8093 0000 		sts hertz+2,r24
 281 0202 9093 0000 		sts hertz+3,r25
  89:main.c        **** 		
  90:main.c        **** 		serial_display(rpm);
 282               		.loc 1 90 0
 283 0206 C701      		movw r24,r14
 284 0208 B601      		movw r22,r12
 285 020a 0E94 0000 		call serial_display
 286               	.LVL24:
  91:main.c        **** 		uart_putc(9);
 287               		.loc 1 91 0
 288 020e 89E0      		ldi r24,lo8(9)
 289 0210 0E94 0000 		call uart_putc
 290               	.LVL25:
  92:main.c        **** 		serial_display(error);
 291               		.loc 1 92 0
 292 0214 6091 0000 		lds r22,error
 293 0218 7091 0000 		lds r23,error+1
 294 021c 8091 0000 		lds r24,error+2
 295 0220 9091 0000 		lds r25,error+3
 296 0224 0E94 0000 		call serial_display
 297               	.LVL26:
  93:main.c        **** 		uart_putc(10);
 298               		.loc 1 93 0
 299 0228 8AE0      		ldi r24,lo8(10)
 300 022a 0E94 0000 		call uart_putc
 301               	.LVL27:
  94:main.c        **** 		
  95:main.c        **** 		error = desired_rpm - rpm;
 302               		.loc 1 95 0
 303 022e 2091 0000 		lds r18,rpm
 304 0232 3091 0000 		lds r19,rpm+1
 305 0236 4091 0000 		lds r20,rpm+2
 306 023a 5091 0000 		lds r21,rpm+3
 307 023e 6091 0000 		lds r22,desired_rpm
 308 0242 7091 0000 		lds r23,desired_rpm+1
 309 0246 8091 0000 		lds r24,desired_rpm+2
 310 024a 9091 0000 		lds r25,desired_rpm+3
 311 024e 0E94 0000 		call __subsf3
 312               	.LVL28:
 313 0252 6093 0000 		sts error,r22
 314 0256 7093 0000 		sts error+1,r23
 315 025a 8093 0000 		sts error+2,r24
 316 025e 9093 0000 		sts error+3,r25
  96:main.c        **** 		bldc_output += pid_output(error, last_error, sampling_rate);
 317               		.loc 1 96 0
 318 0262 C090 8A00 		lds r12,138
 319 0266 D090 8B00 		lds r13,138+1
 320 026a E090 0000 		lds r14,sampling_rate
 321 026e F090 0000 		lds r15,sampling_rate+1
 322 0272 0091 0000 		lds r16,sampling_rate+2
 323 0276 1091 0000 		lds r17,sampling_rate+3
 324 027a 2091 0000 		lds r18,last_error
 325 027e 3091 0000 		lds r19,last_error+1
 326 0282 4091 0000 		lds r20,last_error+2
 327 0286 5091 0000 		lds r21,last_error+3
 328 028a 0E94 0000 		call pid_output
 329               	.LVL29:
 330 028e 9B01      		movw r18,r22
 331 0290 AC01      		movw r20,r24
 332 0292 B601      		movw r22,r12
 333 0294 80E0      		ldi r24,0
 334 0296 90E0      		ldi r25,0
 335 0298 2983      		std Y+1,r18
 336 029a 3A83      		std Y+2,r19
 337 029c 4B83      		std Y+3,r20
 338 029e 5C83      		std Y+4,r21
 339 02a0 0E94 0000 		call __floatunsisf
 340               	.LVL30:
 341 02a4 2981      		ldd r18,Y+1
 342 02a6 3A81      		ldd r19,Y+2
 343 02a8 4B81      		ldd r20,Y+3
 344 02aa 5C81      		ldd r21,Y+4
 345 02ac 0E94 0000 		call __addsf3
 346               	.LVL31:
 347 02b0 0E94 0000 		call __fixunssfsi
 348               	.LVL32:
 349 02b4 7093 8B00 		sts 138+1,r23
 350 02b8 6093 8A00 		sts 138,r22
  97:main.c        **** 		last_error = error;
 351               		.loc 1 97 0
 352 02bc 8091 0000 		lds r24,error
 353 02c0 9091 0000 		lds r25,error+1
 354 02c4 A091 0000 		lds r26,error+2
 355 02c8 B091 0000 		lds r27,error+3
 356 02cc 8093 0000 		sts last_error,r24
 357 02d0 9093 0000 		sts last_error+1,r25
 358 02d4 A093 0000 		sts last_error+2,r26
 359 02d8 B093 0000 		sts last_error+3,r27
  98:main.c        **** 		//	display = true;
  99:main.c        **** 		//	set_pid = false;
 100:main.c        **** 		//if(display){
 101:main.c        **** 			//if(j>=1){
 102:main.c        **** 			//	serial_display(hertz);
 103:main.c        **** 			//	uart_putc(10);
 104:main.c        **** 			//	lcd_clrscr();
 105:main.c        **** 			//	sprintf(buffer, "%.0f rpm       ", rpm);
 106:main.c        **** 			//	lcd_display(0, 0, buffer);
 107:main.c        **** 			//	sprintf(buffer, "%.0f Hertz      ", hertz);
 108:main.c        **** 			//	lcd_display(0, 1, buffer);
 109:main.c        **** 			//	j = 0;
 110:main.c        **** 			//}
 111:main.c        **** 		//	get_rawrpm = true;
 112:main.c        **** 		//	display = false;
 113:main.c        **** 			//j++;
 114:main.c        **** 		//}
 115:main.c        **** 		// if BLDC stop rotating for some times, init again
 116:main.c        **** 		//if((timer2_overflow/100) >= 2000){
 117:main.c        **** 		//	bldc_init();
 118:main.c        **** 		//}
 119:main.c        **** 		
 120:main.c        **** 		
 121:main.c        **** 	}
 360               		.loc 1 121 0
 361 02dc 00C0      		rjmp .L6
 362               		.cfi_endproc
 363               	.LFE8:
 365               		.comm	arr,10,1
 366               		.comm	line,10,1
 367               	.global	j
 368               		.section .bss
 371               	j:
 372 0000 0000      		.zero	2
 373               	.global	i
 376               	i:
 377 0002 0000      		.zero	2
 378               	.global	c
 381               	c:
 382 0004 0000      		.zero	2
 383               	.global	timer2_temp
 386               	timer2_temp:
 387 0006 0000 0000 		.zero	4
 388               	.global	hertz
 391               	hertz:
 392 000a 0000 0000 		.zero	4
 393               	.global	time_stamp
 396               	time_stamp:
 397 000e 0000 0000 		.zero	4
 398               	.global	timer2_overflow_temp
 401               	timer2_overflow_temp:
 402 0012 0000 0000 		.zero	4
 403               	.global	desired_rpm
 404               		.data
 407               	desired_rpm:
 408 0000 00        		.byte	0
 409 0001 40        		.byte	64
 410 0002 9C        		.byte	-100
 411 0003 45        		.byte	69
 412               	.global	last_rpm
 413               		.section .bss
 416               	last_rpm:
 417 0016 0000 0000 		.zero	4
 418               	.global	rpm
 419               		.data
 422               	rpm:
 423 0004 00        		.byte	0
 424 0005 00        		.byte	0
 425 0006 7A        		.byte	122
 426 0007 44        		.byte	68
 427               	.global	last_error
 428               		.section .bss
 431               	last_error:
 432 001a 0000 0000 		.zero	4
 433               	.global	error
 436               	error:
 437 001e 0000 0000 		.zero	4
 438               	.global	sampling_rate
 441               	sampling_rate:
 442 0022 0000 0000 		.zero	4
 443               	.global	data_sampling_time
 446               	data_sampling_time:
 447 0026 0000 0000 		.zero	4
 448               	.global	set_pid
 451               	set_pid:
 452 002a 00        		.zero	1
 453               	.global	display
 456               	display:
 457 002b 00        		.zero	1
 458               	.global	get_rpm
 461               	get_rpm:
 462 002c 00        		.zero	1
 463               	.global	get_rawrpm
 466               	get_rawrpm:
 467 002d 00        		.zero	1
 468               		.comm	buffer,33,1
 469               	.global	timer2_overflow
 472               	timer2_overflow:
 473 002e 0000 0000 		.zero	4
 474               		.text
 475               	.Letext0:
 476               		.file 3 "/usr/lib/avr/include/stdint.h"
 477               		.file 4 "./src/initlib.h"
 478               		.file 5 "./src/timer.h"
 479               		.file 6 "./src/hd44780.h"
 480               		.file 7 "./src/uart.h"
 481               		.file 8 "./src/interface.h"
 482               		.file 9 "./src/pid.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/cccwkA0v.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cccwkA0v.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cccwkA0v.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cccwkA0v.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cccwkA0v.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cccwkA0v.s:20     .text.startup:0000000000000000 main
     /tmp/cccwkA0v.s:451    .bss:000000000000002a set_pid
     /tmp/cccwkA0v.s:441    .bss:0000000000000022 sampling_rate
     /tmp/cccwkA0v.s:446    .bss:0000000000000026 data_sampling_time
     /tmp/cccwkA0v.s:472    .bss:000000000000002e timer2_overflow
     /tmp/cccwkA0v.s:386    .bss:0000000000000006 timer2_temp
     /tmp/cccwkA0v.s:401    .bss:0000000000000012 timer2_overflow_temp
     /tmp/cccwkA0v.s:422    .data:0000000000000004 rpm
     /tmp/cccwkA0v.s:391    .bss:000000000000000a hertz
     /tmp/cccwkA0v.s:436    .bss:000000000000001e error
     /tmp/cccwkA0v.s:407    .data:0000000000000000 desired_rpm
     /tmp/cccwkA0v.s:431    .bss:000000000000001a last_error
                            *COM*:000000000000000a arr
                            *COM*:000000000000000a line
     /tmp/cccwkA0v.s:371    .bss:0000000000000000 j
     /tmp/cccwkA0v.s:376    .bss:0000000000000002 i
     /tmp/cccwkA0v.s:381    .bss:0000000000000004 c
     /tmp/cccwkA0v.s:396    .bss:000000000000000e time_stamp
     /tmp/cccwkA0v.s:416    .bss:0000000000000016 last_rpm
     /tmp/cccwkA0v.s:456    .bss:000000000000002b display
     /tmp/cccwkA0v.s:461    .bss:000000000000002c get_rpm
     /tmp/cccwkA0v.s:466    .bss:000000000000002d get_rawrpm
                            *COM*:0000000000000021 buffer

UNDEFINED SYMBOLS
__floatunsisf
__mulsf3
__addsf3
__ltsf2
__divsf3
__subsf3
__fixunssfsi
timer_init
lcd_init
bldc_init
uart_init
serial_display
uart_putc
pid_output
__do_copy_data
__do_clear_bss
