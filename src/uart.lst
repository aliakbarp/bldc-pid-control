   1               		.file	"uart.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	__vector_18
  12               	__vector_18:
  13               	.LFB2:
  14               		.file 1 "src/uart.c"
   1:src/uart.c    **** /*************************************************************************
   2:src/uart.c    **** Title:    Interrupt UART library with receive/transmit circular buffers
   3:src/uart.c    **** Author:   Peter Fleury <pfleury@gmx.ch>   http://tinyurl.com/peterfleury
   4:src/uart.c    **** File:     $Id: uart.c,v 1.15.2.4 2015/09/05 18:33:32 peter Exp $
   5:src/uart.c    **** Software: AVR-GCC 4.x
   6:src/uart.c    **** Hardware: any AVR with built-in UART, 
   7:src/uart.c    **** License:  GNU General Public License 
   8:src/uart.c    ****           
   9:src/uart.c    **** DESCRIPTION:
  10:src/uart.c    ****     An interrupt is generated when the UART has finished transmitting or
  11:src/uart.c    ****     receiving a byte. The interrupt handling routines use circular buffers
  12:src/uart.c    ****     for buffering received and transmitted data.
  13:src/uart.c    ****     
  14:src/uart.c    ****     The UART_RX_BUFFER_SIZE and UART_TX_BUFFER_SIZE variables define
  15:src/uart.c    ****     the buffer size in bytes. Note that these variables must be a 
  16:src/uart.c    ****     power of 2.
  17:src/uart.c    ****     
  18:src/uart.c    **** USAGE:
  19:src/uart.c    ****     Refere to the header file uart.h for a description of the routines. 
  20:src/uart.c    ****     See also example test_uart.c.
  21:src/uart.c    **** 
  22:src/uart.c    **** NOTES:
  23:src/uart.c    ****     Based on Atmel Application Note AVR306
  24:src/uart.c    ****                     
  25:src/uart.c    **** LICENSE:
  26:src/uart.c    ****     Copyright (C) 2015 Peter Fleury, GNU General Public License Version 3
  27:src/uart.c    **** 
  28:src/uart.c    ****     This program is free software; you can redistribute it and/or modify
  29:src/uart.c    ****     it under the terms of the GNU General Public License as published by
  30:src/uart.c    ****     the Free Software Foundation; either version 2 of the License, or
  31:src/uart.c    ****     any later version.
  32:src/uart.c    **** 
  33:src/uart.c    ****     This program is distributed in the hope that it will be useful,
  34:src/uart.c    ****     but WITHOUT ANY WARRANTY; without even the implied warranty of
  35:src/uart.c    ****     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  36:src/uart.c    ****     GNU General Public License for more details.
  37:src/uart.c    ****                         
  38:src/uart.c    **** *************************************************************************/
  39:src/uart.c    **** #include <avr/io.h>
  40:src/uart.c    **** #include <avr/interrupt.h>
  41:src/uart.c    **** #include <avr/pgmspace.h>
  42:src/uart.c    **** #include <stdbool.h>
  43:src/uart.c    **** #include <stdio.h>
  44:src/uart.c    **** #include <stdlib.h>
  45:src/uart.c    **** #include <string.h>
  46:src/uart.c    **** #include "uart.h"
  47:src/uart.c    **** 
  48:src/uart.c    **** 
  49:src/uart.c    **** /*
  50:src/uart.c    ****  *  constants and macros
  51:src/uart.c    ****  */
  52:src/uart.c    **** 
  53:src/uart.c    **** /* size of RX/TX buffers */
  54:src/uart.c    **** #define UART_RX_BUFFER_MASK ( UART_RX_BUFFER_SIZE - 1)
  55:src/uart.c    **** #define UART_TX_BUFFER_MASK ( UART_TX_BUFFER_SIZE - 1)
  56:src/uart.c    **** 
  57:src/uart.c    **** #if ( UART_RX_BUFFER_SIZE & UART_RX_BUFFER_MASK )
  58:src/uart.c    **** #error RX buffer size is not a power of 2
  59:src/uart.c    **** #endif
  60:src/uart.c    **** #if ( UART_TX_BUFFER_SIZE & UART_TX_BUFFER_MASK )
  61:src/uart.c    **** #error TX buffer size is not a power of 2
  62:src/uart.c    **** #endif
  63:src/uart.c    **** 
  64:src/uart.c    **** 
  65:src/uart.c    **** #if defined(__AVR_AT90S2313__) || defined(__AVR_AT90S4414__) || defined(__AVR_AT90S8515__) || \
  66:src/uart.c    ****     defined(__AVR_AT90S4434__) || defined(__AVR_AT90S8535__) || \
  67:src/uart.c    ****     defined(__AVR_ATmega103__)
  68:src/uart.c    ****  /* old AVR classic or ATmega103 with one UART */
  69:src/uart.c    ****  #define UART0_RECEIVE_INTERRUPT   UART_RX_vect 
  70:src/uart.c    ****  #define UART0_TRANSMIT_INTERRUPT  UART_UDRE_vect
  71:src/uart.c    ****  #define UART0_STATUS      USR
  72:src/uart.c    ****  #define UART0_CONTROL     UCR
  73:src/uart.c    ****  #define UART0_DATA        UDR  
  74:src/uart.c    ****  #define UART0_UDRIE       UDRIE
  75:src/uart.c    ****  #define UART0_UBRRL       UBRR
  76:src/uart.c    ****  #define UART0_BIT_U2X     U2X
  77:src/uart.c    ****  #define UART0_BIT_RXCIE   RXCIE
  78:src/uart.c    ****  #define UART0_BIT_RXEN    RXEN
  79:src/uart.c    ****  #define UART0_BIT_TXEN    TXEN
  80:src/uart.c    **** #elif defined(__AVR_AT90S2333__) || defined(__AVR_AT90S4433__)
  81:src/uart.c    ****  /* old AVR classic with one UART */
  82:src/uart.c    ****  #define UART0_RECEIVE_INTERRUPT   UART_RX_vect 
  83:src/uart.c    ****  #define UART0_TRANSMIT_INTERRUPT  UART_UDRE_vect
  84:src/uart.c    ****  #define UART0_STATUS      UCSRA
  85:src/uart.c    ****  #define UART0_CONTROL     UCSRB
  86:src/uart.c    ****  #define UART0_DATA        UDR 
  87:src/uart.c    ****  #define UART0_UDRIE       UDRIE
  88:src/uart.c    ****  #define UART0_UBRRL       UBRR
  89:src/uart.c    ****  #define UART0_BIT_U2X     U2X
  90:src/uart.c    ****  #define UART0_BIT_RXCIE   RXCIE
  91:src/uart.c    ****  #define UART0_BIT_RXEN    RXEN
  92:src/uart.c    ****  #define UART0_BIT_TXEN    TXEN
  93:src/uart.c    **** #elif defined(__AVR_AT90PWM216__) || defined(__AVR_AT90PWM316__) 
  94:src/uart.c    ****  /* AT90PWN216/316 with one USART */
  95:src/uart.c    ****  #define UART0_RECEIVE_INTERRUPT   USART_RX_vect
  96:src/uart.c    ****  #define UART0_TRANSMIT_INTERRUPT  USART_UDRE_vect
  97:src/uart.c    ****  #define UART0_STATUS      UCSRA
  98:src/uart.c    ****  #define UART0_CONTROL     UCSRB
  99:src/uart.c    ****  #define UART0_CONTROLC    UCSRC
 100:src/uart.c    ****  #define UART0_DATA        UDR
 101:src/uart.c    ****  #define UART0_UDRIE       UDRIE
 102:src/uart.c    ****  #define UART0_UBRRL       UBRRL
 103:src/uart.c    ****  #define UART0_UBRRH       UBRRH
 104:src/uart.c    ****  #define UART0_BIT_U2X     U2X
 105:src/uart.c    ****  #define UART0_BIT_RXCIE   RXCIE
 106:src/uart.c    ****  #define UART0_BIT_RXEN    RXEN
 107:src/uart.c    ****  #define UART0_BIT_TXEN    TXEN
 108:src/uart.c    ****  #define UART0_BIT_UCSZ0   UCSZ0
 109:src/uart.c    ****  #define UART0_BIT_UCSZ1   UCSZ1 
 110:src/uart.c    **** #elif defined(__AVR_ATmega8__) || defined(__AVR_ATmega8A__) || \
 111:src/uart.c    ****       defined(__AVR_ATmega16__) || defined(__AVR_ATmega16A__) || \
 112:src/uart.c    ****       defined(__AVR_ATmega32__) || defined(__AVR_ATmega32A__) || \
 113:src/uart.c    ****       defined(__AVR_ATmega323__)
 114:src/uart.c    ****  /* ATmega with one USART */
 115:src/uart.c    ****  #define UART0_RECEIVE_INTERRUPT   USART_RXC_vect
 116:src/uart.c    ****  #define UART0_TRANSMIT_INTERRUPT  USART_UDRE_vect
 117:src/uart.c    ****  #define UART0_STATUS      UCSRA
 118:src/uart.c    ****  #define UART0_CONTROL     UCSRB
 119:src/uart.c    ****  #define UART0_CONTROLC    UCSRC
 120:src/uart.c    ****  #define UART0_DATA        UDR
 121:src/uart.c    ****  #define UART0_UDRIE       UDRIE
 122:src/uart.c    ****  #define UART0_UBRRL       UBRRL
 123:src/uart.c    ****  #define UART0_UBRRH       UBRRH
 124:src/uart.c    ****  #define UART0_BIT_U2X     U2X
 125:src/uart.c    ****  #define UART0_BIT_RXCIE   RXCIE
 126:src/uart.c    ****  #define UART0_BIT_RXEN    RXEN
 127:src/uart.c    ****  #define UART0_BIT_TXEN    TXEN
 128:src/uart.c    ****  #define UART0_BIT_UCSZ0   UCSZ0
 129:src/uart.c    ****  #define UART0_BIT_UCSZ1   UCSZ1
 130:src/uart.c    ****  #define UART0_BIT_URSEL   URSEL
 131:src/uart.c    **** #elif defined (__AVR_ATmega8515__) || defined(__AVR_ATmega8535__)
 132:src/uart.c    ****  #define UART0_RECEIVE_INTERRUPT   USART_RX_vect
 133:src/uart.c    ****  #define UART0_TRANSMIT_INTERRUPT  USART_UDRE_vect
 134:src/uart.c    ****  #define UART0_STATUS      UCSRA
 135:src/uart.c    ****  #define UART0_CONTROL     UCSRB
 136:src/uart.c    ****  #define UART0_CONTROLC    UCSRC 
 137:src/uart.c    ****  #define UART0_DATA        UDR
 138:src/uart.c    ****  #define UART0_UDRIE       UDRIE
 139:src/uart.c    ****  #define UART0_UBRRL       UBRRL
 140:src/uart.c    ****  #define UART0_UBRRH       UBRRH
 141:src/uart.c    ****  #define UART0_BIT_U2X     U2X
 142:src/uart.c    ****  #define UART0_BIT_RXCIE   RXCIE
 143:src/uart.c    ****  #define UART0_BIT_RXEN    RXEN
 144:src/uart.c    ****  #define UART0_BIT_TXEN    TXEN
 145:src/uart.c    ****  #define UART0_BIT_UCSZ0   UCSZ0
 146:src/uart.c    ****  #define UART0_BIT_UCSZ1   UCSZ1
 147:src/uart.c    ****  #define UART0_BIT_URSEL   URSEL
 148:src/uart.c    **** #elif defined(__AVR_ATmega163__)
 149:src/uart.c    ****   /* ATmega163 with one UART */
 150:src/uart.c    ****  #define UART0_RECEIVE_INTERRUPT   UART_RX_vect
 151:src/uart.c    ****  #define UART0_TRANSMIT_INTERRUPT  UART_UDRE_vect
 152:src/uart.c    ****  #define UART0_STATUS      UCSRA
 153:src/uart.c    ****  #define UART0_CONTROL     UCSRB
 154:src/uart.c    ****  #define UART0_DATA        UDR
 155:src/uart.c    ****  #define UART0_UDRIE       UDRIE
 156:src/uart.c    ****  #define UART0_UBRRL       UBRR
 157:src/uart.c    ****  #define UART0_UBRRH       UBRRHI
 158:src/uart.c    ****  #define UART0_BIT_U2X     U2X
 159:src/uart.c    ****  #define UART0_BIT_RXCIE   RXCIE
 160:src/uart.c    ****  #define UART0_BIT_RXEN    RXEN
 161:src/uart.c    ****  #define UART0_BIT_TXEN    TXEN
 162:src/uart.c    **** #elif defined(__AVR_ATmega162__) 
 163:src/uart.c    ****  /* ATmega with two USART */
 164:src/uart.c    ****  #define ATMEGA_USART1
 165:src/uart.c    ****  #define UART0_RECEIVE_INTERRUPT   USART0_RXC_vect
 166:src/uart.c    ****  #define UART1_RECEIVE_INTERRUPT   USART1_RXC_vect
 167:src/uart.c    ****  #define UART0_TRANSMIT_INTERRUPT  USART0_UDRE_vect
 168:src/uart.c    ****  #define UART1_TRANSMIT_INTERRUPT  USART1_UDRE_vect
 169:src/uart.c    ****  #define UART0_STATUS      UCSR0A
 170:src/uart.c    ****  #define UART0_CONTROL     UCSR0B
 171:src/uart.c    ****  #define UART0_CONTROLC    UCSR0C
 172:src/uart.c    ****  #define UART0_DATA        UDR0
 173:src/uart.c    ****  #define UART0_UDRIE       UDRIE0
 174:src/uart.c    ****  #define UART0_UBRRL       UBRR0L
 175:src/uart.c    ****  #define UART0_UBRRH       UBRR0H
 176:src/uart.c    ****  #define UART0_BIT_URSEL   URSEL0
 177:src/uart.c    ****  #define UART0_BIT_U2X     U2X0
 178:src/uart.c    ****  #define UART0_BIT_RXCIE   RXCIE0
 179:src/uart.c    ****  #define UART0_BIT_RXEN    RXEN0
 180:src/uart.c    ****  #define UART0_BIT_TXEN    TXEN0
 181:src/uart.c    ****  #define UART0_BIT_UCSZ0   UCSZ00
 182:src/uart.c    ****  #define UART0_BIT_UCSZ1   UCSZ01
 183:src/uart.c    ****  #define UART1_STATUS      UCSR1A
 184:src/uart.c    ****  #define UART1_CONTROL     UCSR1B
 185:src/uart.c    ****  #define UART1_CONTROLC    UCSR1C
 186:src/uart.c    ****  #define UART1_DATA        UDR1
 187:src/uart.c    ****  #define UART1_UDRIE       UDRIE1
 188:src/uart.c    ****  #define UART1_UBRRL       UBRR1L
 189:src/uart.c    ****  #define UART1_UBRRH       UBRR1H
 190:src/uart.c    ****  #define UART1_BIT_URSEL   URSEL1
 191:src/uart.c    ****  #define UART1_BIT_U2X     U2X1
 192:src/uart.c    ****  #define UART1_BIT_RXCIE   RXCIE1
 193:src/uart.c    ****  #define UART1_BIT_RXEN    RXEN1
 194:src/uart.c    ****  #define UART1_BIT_TXEN    TXEN1
 195:src/uart.c    ****  #define UART1_BIT_UCSZ0   UCSZ10
 196:src/uart.c    ****  #define UART1_BIT_UCSZ1   UCSZ11 
 197:src/uart.c    **** #elif defined(__AVR_ATmega161__)
 198:src/uart.c    ****  /* ATmega with UART */
 199:src/uart.c    ****  #error "AVR ATmega161 currently not supported by this libaray !"
 200:src/uart.c    **** #elif defined(__AVR_ATmega169__)
 201:src/uart.c    ****  /* ATmega with one USART */
 202:src/uart.c    ****  #define UART0_RECEIVE_INTERRUPT   USART0_RX_vect
 203:src/uart.c    ****  #define UART0_TRANSMIT_INTERRUPT  USART0_UDRE_vect
 204:src/uart.c    ****  #define UART0_STATUS      UCSRA
 205:src/uart.c    ****  #define UART0_CONTROL     UCSRB
 206:src/uart.c    ****  #define UART0_CONTROLC    UCSRC
 207:src/uart.c    ****  #define UART0_DATA        UDR
 208:src/uart.c    ****  #define UART0_UDRIE       UDRIE
 209:src/uart.c    ****  #define UART0_UBRRL       UBRRL
 210:src/uart.c    ****  #define UART0_UBRRH       UBRRH
 211:src/uart.c    ****  #define UART0_BIT_U2X     U2X
 212:src/uart.c    ****  #define UART0_BIT_RXCIE   RXCIE
 213:src/uart.c    ****  #define UART0_BIT_RXEN    RXEN
 214:src/uart.c    ****  #define UART0_BIT_TXEN    TXEN
 215:src/uart.c    ****  #define UART0_BIT_UCSZ0   UCSZ0
 216:src/uart.c    ****  #define UART0_BIT_UCSZ1   UCSZ1
 217:src/uart.c    **** #elif defined(__AVR_ATmega48__) || defined(__AVR_ATmega48A__) || defined(__AVR_ATmega48P__) || defi
 218:src/uart.c    ****       defined(__AVR_ATmega88__) || defined(__AVR_ATmega88A__) || defined(__AVR_ATmega88P__) || defi
 219:src/uart.c    ****       defined(__AVR_ATmega168__) || defined(__AVR_ATmega168A__)|| defined(__AVR_ATmega168P__)|| def
 220:src/uart.c    ****       defined(__AVR_ATmega328__) || defined(__AVR_ATmega328P__) || \
 221:src/uart.c    ****       defined(__AVR_ATmega3250__) || defined(__AVR_ATmega3290__) ||defined(__AVR_ATmega6450__) || d
 222:src/uart.c    ****  /* ATmega with one USART */
 223:src/uart.c    ****  #define UART0_RECEIVE_INTERRUPT   USART_RX_vect
 224:src/uart.c    ****  #define UART0_TRANSMIT_INTERRUPT  USART_UDRE_vect
 225:src/uart.c    ****  #define UART0_STATUS      UCSR0A
 226:src/uart.c    ****  #define UART0_CONTROL     UCSR0B
 227:src/uart.c    ****  #define UART0_CONTROLC    UCSR0C
 228:src/uart.c    ****  #define UART0_DATA        UDR0
 229:src/uart.c    ****  #define UART0_UDRIE       UDRIE0
 230:src/uart.c    ****  #define UART0_UBRRL       UBRR0L
 231:src/uart.c    ****  #define UART0_UBRRH       UBRR0H
 232:src/uart.c    ****  #define UART0_BIT_U2X     U2X0
 233:src/uart.c    ****  #define UART0_BIT_RXCIE   RXCIE0
 234:src/uart.c    ****  #define UART0_BIT_RXEN    RXEN0
 235:src/uart.c    ****  #define UART0_BIT_TXEN    TXEN0
 236:src/uart.c    ****  #define UART0_BIT_UCSZ0   UCSZ00
 237:src/uart.c    ****  #define UART0_BIT_UCSZ1   UCSZ01
 238:src/uart.c    **** #elif defined(__AVR_ATtiny2313__) || defined(__AVR_ATtiny2313A__) || defined(__AVR_ATtiny4313__)
 239:src/uart.c    ****  /* ATtiny with one USART */
 240:src/uart.c    ****  #define UART0_RECEIVE_INTERRUPT   USART_RX_vect
 241:src/uart.c    ****  #define UART0_TRANSMIT_INTERRUPT  USART_UDRE_vect
 242:src/uart.c    ****  #define UART0_STATUS      UCSRA
 243:src/uart.c    ****  #define UART0_CONTROL     UCSRB
 244:src/uart.c    ****  #define UART0_CONTROLC    UCSRC
 245:src/uart.c    ****  #define UART0_DATA        UDR
 246:src/uart.c    ****  #define UART0_UDRIE       UDRIE
 247:src/uart.c    ****  #define UART0_UBRRL       UBRRL
 248:src/uart.c    ****  #define UART0_UBRRH       UBRRH
 249:src/uart.c    ****  #define UART0_BIT_U2X     U2X
 250:src/uart.c    ****  #define UART0_BIT_RXCIE   RXCIE
 251:src/uart.c    ****  #define UART0_BIT_RXEN    RXEN
 252:src/uart.c    ****  #define UART0_BIT_TXEN    TXEN
 253:src/uart.c    ****  #define UART0_BIT_UCSZ0   UCSZ0
 254:src/uart.c    ****  #define UART0_BIT_UCSZ1   UCSZ1
 255:src/uart.c    **** #elif defined(__AVR_ATmega329__) || defined(__AVR_ATmega649__) || defined(__AVR_ATmega3290__) || de
 256:src/uart.c    ****       defined(__AVR_ATmega169A__) || defined(__AVR_ATmega169PA__) || \
 257:src/uart.c    ****       defined(__AVR_ATmega329A__) || defined(__AVR_ATmega329PA__) || defined(__AVR_ATmega3290A__) |
 258:src/uart.c    ****       defined(__AVR_ATmega649A__) || defined(__AVR_ATmega649P__) || defined(__AVR_ATmega6490A__) ||
 259:src/uart.c    ****       defined(__AVR_ATmega165__) || defined(__AVR_ATmega325__) || defined(__AVR_ATmega645__) || def
 260:src/uart.c    ****       defined(__AVR_ATmega165A__) || defined(__AVR_ATmega165PA__) || \
 261:src/uart.c    ****       defined(__AVR_ATmega325A__) || defined(__AVR_ATmega325PA__) || defined(__AVR_ATmega3250A__) |
 262:src/uart.c    ****       defined(__AVR_ATmega645A__) || defined(__AVR_ATmega645PA__) || defined(__AVR_ATmega6450A__) |
 263:src/uart.c    ****       defined(__AVR_ATmega644__)
 264:src/uart.c    ****  /* ATmega with one USART */
 265:src/uart.c    ****  #define UART0_RECEIVE_INTERRUPT   USART0_RX_vect
 266:src/uart.c    ****  #define UART0_TRANSMIT_INTERRUPT  USART0_UDRE_vect
 267:src/uart.c    ****  #define UART0_STATUS      UCSR0A
 268:src/uart.c    ****  #define UART0_CONTROL     UCSR0B
 269:src/uart.c    ****  #define UART0_CONTROLC    UCSR0C
 270:src/uart.c    ****  #define UART0_DATA        UDR0
 271:src/uart.c    ****  #define UART0_UDRIE       UDRIE0
 272:src/uart.c    ****  #define UART0_UBRRL       UBRR0L
 273:src/uart.c    ****  #define UART0_UBRRH       UBRR0H
 274:src/uart.c    ****  #define UART0_BIT_U2X     U2X0
 275:src/uart.c    ****  #define UART0_BIT_RXCIE   RXCIE0
 276:src/uart.c    ****  #define UART0_BIT_RXEN    RXEN0
 277:src/uart.c    ****  #define UART0_BIT_TXEN    TXEN0
 278:src/uart.c    ****  #define UART0_BIT_UCSZ0   UCSZ00
 279:src/uart.c    ****  #define UART0_BIT_UCSZ1   UCSZ01
 280:src/uart.c    **** #elif defined(__AVR_ATmega64__) || defined(__AVR_ATmega128__) || defined(__AVR_ATmega128A__) ||\
 281:src/uart.c    ****       defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || d
 282:src/uart.c    ****       defined(__AVR_ATmega164P__) || defined(__AVR_ATmega324P__) || defined(__AVR_ATmega644P__) || 
 283:src/uart.c    ****       defined(__AVR_ATmega164A__) || defined(__AVR_ATmega164PA__) || defined(__AVR_ATmega324A__) ||
 284:src/uart.c    ****       defined(__AVR_ATmega644A__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284__) ||
 285:src/uart.c    ****       defined(__AVR_ATtiny1634__)
 286:src/uart.c    ****  /* ATmega with two USART */
 287:src/uart.c    ****  #define ATMEGA_USART1
 288:src/uart.c    ****  #define UART0_RECEIVE_INTERRUPT   USART0_RX_vect
 289:src/uart.c    ****  #define UART1_RECEIVE_INTERRUPT   USART1_RX_vect
 290:src/uart.c    ****  #define UART0_TRANSMIT_INTERRUPT  USART0_UDRE_vect
 291:src/uart.c    ****  #define UART1_TRANSMIT_INTERRUPT  USART1_UDRE_vect
 292:src/uart.c    ****  #define UART0_STATUS      UCSR0A
 293:src/uart.c    ****  #define UART0_CONTROL     UCSR0B
 294:src/uart.c    ****  #define UART0_CONTROLC    UCSR0C  
 295:src/uart.c    ****  #define UART0_DATA        UDR0
 296:src/uart.c    ****  #define UART0_UDRIE       UDRIE0
 297:src/uart.c    ****  #define UART0_UBRRL       UBRR0L
 298:src/uart.c    ****  #define UART0_UBRRH       UBRR0H
 299:src/uart.c    ****  #define UART0_BIT_U2X     U2X0
 300:src/uart.c    ****  #define UART0_BIT_RXCIE   RXCIE0
 301:src/uart.c    ****  #define UART0_BIT_RXEN    RXEN0
 302:src/uart.c    ****  #define UART0_BIT_TXEN    TXEN0
 303:src/uart.c    ****  #define UART0_BIT_UCSZ0   UCSZ00
 304:src/uart.c    ****  #define UART0_BIT_UCSZ1   UCSZ01 
 305:src/uart.c    ****  #define UART1_STATUS      UCSR1A
 306:src/uart.c    ****  #define UART1_CONTROL     UCSR1B
 307:src/uart.c    ****  #define UART1_CONTROLC    UCSR1C  
 308:src/uart.c    ****  #define UART1_DATA        UDR1
 309:src/uart.c    ****  #define UART1_UDRIE       UDRIE1
 310:src/uart.c    ****  #define UART1_UBRRL       UBRR1L
 311:src/uart.c    ****  #define UART1_UBRRH       UBRR1H
 312:src/uart.c    ****  #define UART1_BIT_U2X     U2X1
 313:src/uart.c    ****  #define UART1_BIT_RXCIE   RXCIE1
 314:src/uart.c    ****  #define UART1_BIT_RXEN    RXEN1
 315:src/uart.c    ****  #define UART1_BIT_TXEN    TXEN1
 316:src/uart.c    ****  #define UART1_BIT_UCSZ0   UCSZ10
 317:src/uart.c    ****  #define UART1_BIT_UCSZ1   UCSZ11
 318:src/uart.c    **** #elif defined(__AVR_ATmega8U2__) || defined(__AVR_ATmega16U2__) || defined(__AVR_ATmega32U2__) || \
 319:src/uart.c    ****       defined(__AVR_ATmega16U4__) || defined(__AVR_ATmega32U4__) || \
 320:src/uart.c    ****       defined(__AVR_AT90USB82__) || defined(__AVR_AT90USB162__) || \
 321:src/uart.c    ****       defined(__AVR_AT90USB646__) || defined(__AVR_AT90USB1286__) || defined(__AVR_AT90USB647__) ||
 322:src/uart.c    ****  #define UART0_RECEIVE_INTERRUPT   USART1_RX_vect
 323:src/uart.c    ****  #define UART0_TRANSMIT_INTERRUPT  USART1_UDRE_vect
 324:src/uart.c    ****  #define UART0_STATUS      UCSR1A
 325:src/uart.c    ****  #define UART0_CONTROL     UCSR1B
 326:src/uart.c    ****  #define UART0_CONTROLC    UCSR1C
 327:src/uart.c    ****  #define UART0_DATA        UDR1
 328:src/uart.c    ****  #define UART0_UDRIE       UDRIE1
 329:src/uart.c    ****  #define UART0_UBRRL       UBRR1L
 330:src/uart.c    ****  #define UART0_UBRRH       UBRR1H
 331:src/uart.c    ****  #define UART0_BIT_U2X     U2X1
 332:src/uart.c    ****  #define UART0_BIT_RXCIE   RXCIE1
 333:src/uart.c    ****  #define UART0_BIT_RXEN    RXEN1
 334:src/uart.c    ****  #define UART0_BIT_TXEN    TXEN1
 335:src/uart.c    ****  #define UART0_BIT_UCSZ0   UCSZ10
 336:src/uart.c    ****  #define UART0_BIT_UCSZ1   UCSZ11
 337:src/uart.c    **** #else
 338:src/uart.c    ****  #error "no UART definition for MCU available"
 339:src/uart.c    **** #endif
 340:src/uart.c    **** 
 341:src/uart.c    **** 
 342:src/uart.c    **** 
 343:src/uart.c    **** /*
 344:src/uart.c    ****  *  module global variables
 345:src/uart.c    ****  */
 346:src/uart.c    **** static volatile unsigned char UART_TxBuf[UART_TX_BUFFER_SIZE];
 347:src/uart.c    **** static volatile unsigned char UART_RxBuf[UART_RX_BUFFER_SIZE];
 348:src/uart.c    **** static volatile unsigned char UART_TxHead;
 349:src/uart.c    **** static volatile unsigned char UART_TxTail;
 350:src/uart.c    **** static volatile unsigned char UART_RxHead;
 351:src/uart.c    **** static volatile unsigned char UART_RxTail;
 352:src/uart.c    **** static volatile unsigned char UART_LastRxError;
 353:src/uart.c    **** 
 354:src/uart.c    **** #if defined( ATMEGA_USART1 )
 355:src/uart.c    **** static volatile unsigned char UART1_TxBuf[UART_TX_BUFFER_SIZE];
 356:src/uart.c    **** static volatile unsigned char UART1_RxBuf[UART_RX_BUFFER_SIZE];
 357:src/uart.c    **** static volatile unsigned char UART1_TxHead;
 358:src/uart.c    **** static volatile unsigned char UART1_TxTail;
 359:src/uart.c    **** static volatile unsigned char UART1_RxHead;
 360:src/uart.c    **** static volatile unsigned char UART1_RxTail;
 361:src/uart.c    **** static volatile unsigned char UART1_LastRxError;
 362:src/uart.c    **** #endif
 363:src/uart.c    **** 
 364:src/uart.c    **** 
 365:src/uart.c    **** 
 366:src/uart.c    **** ISR (UART0_RECEIVE_INTERRUPT)	
 367:src/uart.c    **** /*************************************************************************
 368:src/uart.c    **** Function: UART Receive Complete interrupt
 369:src/uart.c    **** Purpose:  called when the UART has received a character
 370:src/uart.c    **** **************************************************************************/
 371:src/uart.c    **** {
  15               		.loc 1 371 0
  16               		.cfi_startproc
  17 0000 1F92      		push r1
  18               	.LCFI0:
  19               		.cfi_def_cfa_offset 3
  20               		.cfi_offset 1, -2
  21 0002 0F92      		push r0
  22               	.LCFI1:
  23               		.cfi_def_cfa_offset 4
  24               		.cfi_offset 0, -3
  25 0004 0FB6      		in r0,__SREG__
  26 0006 0F92      		push r0
  27 0008 1124      		clr __zero_reg__
  28 000a 2F93      		push r18
  29               	.LCFI2:
  30               		.cfi_def_cfa_offset 5
  31               		.cfi_offset 18, -4
  32 000c 3F93      		push r19
  33               	.LCFI3:
  34               		.cfi_def_cfa_offset 6
  35               		.cfi_offset 19, -5
  36 000e 4F93      		push r20
  37               	.LCFI4:
  38               		.cfi_def_cfa_offset 7
  39               		.cfi_offset 20, -6
  40 0010 5F93      		push r21
  41               	.LCFI5:
  42               		.cfi_def_cfa_offset 8
  43               		.cfi_offset 21, -7
  44 0012 6F93      		push r22
  45               	.LCFI6:
  46               		.cfi_def_cfa_offset 9
  47               		.cfi_offset 22, -8
  48 0014 7F93      		push r23
  49               	.LCFI7:
  50               		.cfi_def_cfa_offset 10
  51               		.cfi_offset 23, -9
  52 0016 8F93      		push r24
  53               	.LCFI8:
  54               		.cfi_def_cfa_offset 11
  55               		.cfi_offset 24, -10
  56 0018 9F93      		push r25
  57               	.LCFI9:
  58               		.cfi_def_cfa_offset 12
  59               		.cfi_offset 25, -11
  60 001a AF93      		push r26
  61               	.LCFI10:
  62               		.cfi_def_cfa_offset 13
  63               		.cfi_offset 26, -12
  64 001c BF93      		push r27
  65               	.LCFI11:
  66               		.cfi_def_cfa_offset 14
  67               		.cfi_offset 27, -13
  68 001e CF93      		push r28
  69               	.LCFI12:
  70               		.cfi_def_cfa_offset 15
  71               		.cfi_offset 28, -14
  72 0020 EF93      		push r30
  73               	.LCFI13:
  74               		.cfi_def_cfa_offset 16
  75               		.cfi_offset 30, -15
  76 0022 FF93      		push r31
  77               	.LCFI14:
  78               		.cfi_def_cfa_offset 17
  79               		.cfi_offset 31, -16
  80               	/* prologue: Signal */
  81               	/* frame size = 0 */
  82               	/* stack size = 16 */
  83               	.L__stack_usage = 16
 372:src/uart.c    ****     unsigned char tmphead;
 373:src/uart.c    ****     unsigned char data;
 374:src/uart.c    ****     unsigned char usr;
 375:src/uart.c    ****     unsigned char lastRxError;
 376:src/uart.c    ****     extern unsigned char line[10];
 377:src/uart.c    ****     extern unsigned int i;
 378:src/uart.c    **** 	extern bool serial_complete;
 379:src/uart.c    **** 	extern double desired_rpm;
 380:src/uart.c    ****  
 381:src/uart.c    ****     /* read UART status register and UART data register */
 382:src/uart.c    ****     usr  = UART0_STATUS;
  84               		.loc 1 382 0
  85 0024 C091 C000 		lds r28,192
  86               	.LVL0:
 383:src/uart.c    ****     data = UART0_DATA;
  87               		.loc 1 383 0
  88 0028 2091 C600 		lds r18,198
  89               	.LVL1:
 384:src/uart.c    ****     
 385:src/uart.c    ****     /* get FEn (Frame Error) DORn (Data OverRun) UPEn (USART Parity Error) bits */
 386:src/uart.c    **** #if defined(FE) && defined(DOR) && defined(UPE)
 387:src/uart.c    ****     lastRxError = usr & (_BV(FE)|_BV(DOR)|_BV(UPE) );
 388:src/uart.c    **** #elif defined(FE0) && defined(DOR0) && defined(UPE0)
 389:src/uart.c    ****     lastRxError = usr & (_BV(FE0)|_BV(DOR0)|_BV(UPE0) );
 390:src/uart.c    **** #elif defined(FE1) && defined(DOR1) && defined(UPE1)
 391:src/uart.c    ****     lastRxError = usr & (_BV(FE1)|_BV(DOR1)|_BV(UPE1) );
 392:src/uart.c    **** #elif defined(FE) && defined(DOR)
 393:src/uart.c    ****     lastRxError = usr & (_BV(FE)|_BV(DOR) );
 394:src/uart.c    **** #endif
 395:src/uart.c    **** 
 396:src/uart.c    ****     /* calculate buffer index */ 
 397:src/uart.c    ****     tmphead = ( UART_RxHead + 1) & UART_RX_BUFFER_MASK;
  90               		.loc 1 397 0
  91 002c E091 0000 		lds r30,UART_RxHead
  92 0030 EF5F      		subi r30,lo8(-(1))
  93 0032 EF71      		andi r30,lo8(31)
  94               	.LVL2:
 398:src/uart.c    ****     
 399:src/uart.c    ****     if ( tmphead == UART_RxTail ) {
  95               		.loc 1 399 0
  96 0034 8091 0000 		lds r24,UART_RxTail
  97 0038 E817      		cp r30,r24
  98 003a 01F0      		breq .L7
 389:src/uart.c    ****     lastRxError = usr & (_BV(FE0)|_BV(DOR0)|_BV(UPE0) );
  99               		.loc 1 389 0
 100 003c CC71      		andi r28,lo8(28)
 101               	.LVL3:
 400:src/uart.c    ****         /* error: receive buffer overflow */
 401:src/uart.c    ****         lastRxError = UART_BUFFER_OVERFLOW >> 8;
 402:src/uart.c    ****     }else{
 403:src/uart.c    ****         /* store new index */
 404:src/uart.c    ****         UART_RxHead = tmphead;
 102               		.loc 1 404 0
 103 003e E093 0000 		sts UART_RxHead,r30
 405:src/uart.c    ****         /* store received data in buffer */
 406:src/uart.c    ****         UART_RxBuf[tmphead] = data;
 104               		.loc 1 406 0
 105 0042 F0E0      		ldi r31,0
 106 0044 E050      		subi r30,lo8(-(UART_RxBuf))
 107 0046 F040      		sbci r31,hi8(-(UART_RxBuf))
 108               	.LVL4:
 109 0048 2083      		st Z,r18
 110               	.LVL5:
 111 004a 00C0      		rjmp .L2
 112               	.LVL6:
 113               	.L7:
 401:src/uart.c    ****         lastRxError = UART_BUFFER_OVERFLOW >> 8;
 114               		.loc 1 401 0
 115 004c C2E0      		ldi r28,lo8(2)
 116               	.LVL7:
 117               	.L2:
 407:src/uart.c    ****     }
 408:src/uart.c    **** 
 409:src/uart.c    **** 	if(data != 10){
 118               		.loc 1 409 0
 119 004e 2A30      		cpi r18,lo8(10)
 120 0050 01F0      		breq .L3
 410:src/uart.c    **** 		if(data >= 48){
 121               		.loc 1 410 0
 122 0052 2033      		cpi r18,lo8(48)
 123 0054 00F0      		brlo .L4
 411:src/uart.c    **** 			line[i] = data;
 124               		.loc 1 411 0
 125 0056 8091 0000 		lds r24,i
 126 005a 9091 0000 		lds r25,i+1
 127 005e FC01      		movw r30,r24
 128 0060 E050      		subi r30,lo8(-(line))
 129 0062 F040      		sbci r31,hi8(-(line))
 130 0064 2083      		st Z,r18
 412:src/uart.c    **** 			i++;
 131               		.loc 1 412 0
 132 0066 0196      		adiw r24,1
 133 0068 9093 0000 		sts i+1,r25
 134 006c 8093 0000 		sts i,r24
 135 0070 00C0      		rjmp .L4
 136               	.L3:
 413:src/uart.c    **** 		}
 414:src/uart.c    **** 	} else {
 415:src/uart.c    **** 		desired_rpm = atof(line);
 137               		.loc 1 415 0
 138 0072 80E0      		ldi r24,lo8(line)
 139 0074 90E0      		ldi r25,hi8(line)
 140 0076 0E94 0000 		call atof
 141               	.LVL8:
 142 007a 6093 0000 		sts desired_rpm,r22
 143 007e 7093 0000 		sts desired_rpm+1,r23
 144 0082 8093 0000 		sts desired_rpm+2,r24
 145 0086 9093 0000 		sts desired_rpm+3,r25
 146               	.LVL9:
 147 008a E0E0      		ldi r30,lo8(line)
 148 008c F0E0      		ldi r31,hi8(line)
 149               	.LVL10:
 150               	.L6:
 151               	.LBB2:
 416:src/uart.c    **** 		for(int g=0; g<10; g++){
 417:src/uart.c    **** 			line[g] = 0;
 152               		.loc 1 417 0 discriminator 2
 153 008e 1192      		st Z+,__zero_reg__
 154               	.LVL11:
 416:src/uart.c    **** 		for(int g=0; g<10; g++){
 155               		.loc 1 416 0 discriminator 2
 156 0090 80E0      		ldi r24,hi8(line+10)
 157 0092 E030      		cpi r30,lo8(line+10)
 158 0094 F807      		cpc r31,r24
 159 0096 01F4      		brne .L6
 160               	.LBE2:
 418:src/uart.c    **** 		}
 419:src/uart.c    **** 		i = 0;
 161               		.loc 1 419 0
 162 0098 1092 0000 		sts i+1,__zero_reg__
 163 009c 1092 0000 		sts i,__zero_reg__
 164               	.LVL12:
 165               	.L4:
 420:src/uart.c    **** 	}
 421:src/uart.c    **** 	
 422:src/uart.c    ****     UART_LastRxError |= lastRxError;   
 166               		.loc 1 422 0
 167 00a0 8091 0000 		lds r24,UART_LastRxError
 168 00a4 8C2B      		or r24,r28
 169 00a6 8093 0000 		sts UART_LastRxError,r24
 170               	/* epilogue start */
 423:src/uart.c    **** }
 171               		.loc 1 423 0
 172 00aa FF91      		pop r31
 173 00ac EF91      		pop r30
 174 00ae CF91      		pop r28
 175               	.LVL13:
 176 00b0 BF91      		pop r27
 177 00b2 AF91      		pop r26
 178 00b4 9F91      		pop r25
 179 00b6 8F91      		pop r24
 180 00b8 7F91      		pop r23
 181 00ba 6F91      		pop r22
 182 00bc 5F91      		pop r21
 183 00be 4F91      		pop r20
 184 00c0 3F91      		pop r19
 185 00c2 2F91      		pop r18
 186 00c4 0F90      		pop r0
 187 00c6 0FBE      		out __SREG__,r0
 188 00c8 0F90      		pop r0
 189 00ca 1F90      		pop r1
 190 00cc 1895      		reti
 191               		.cfi_endproc
 192               	.LFE2:
 194               	.global	__vector_19
 196               	__vector_19:
 197               	.LFB3:
 424:src/uart.c    **** 
 425:src/uart.c    **** 
 426:src/uart.c    **** ISR (UART0_TRANSMIT_INTERRUPT)
 427:src/uart.c    **** /*************************************************************************
 428:src/uart.c    **** Function: UART Data Register Empty interrupt
 429:src/uart.c    **** Purpose:  called when the UART is ready to transmit the next byte
 430:src/uart.c    **** **************************************************************************/
 431:src/uart.c    **** {
 198               		.loc 1 431 0
 199               		.cfi_startproc
 200 00ce 1F92      		push r1
 201               	.LCFI15:
 202               		.cfi_def_cfa_offset 3
 203               		.cfi_offset 1, -2
 204 00d0 0F92      		push r0
 205               	.LCFI16:
 206               		.cfi_def_cfa_offset 4
 207               		.cfi_offset 0, -3
 208 00d2 0FB6      		in r0,__SREG__
 209 00d4 0F92      		push r0
 210 00d6 1124      		clr __zero_reg__
 211 00d8 8F93      		push r24
 212               	.LCFI17:
 213               		.cfi_def_cfa_offset 5
 214               		.cfi_offset 24, -4
 215 00da 9F93      		push r25
 216               	.LCFI18:
 217               		.cfi_def_cfa_offset 6
 218               		.cfi_offset 25, -5
 219 00dc EF93      		push r30
 220               	.LCFI19:
 221               		.cfi_def_cfa_offset 7
 222               		.cfi_offset 30, -6
 223 00de FF93      		push r31
 224               	.LCFI20:
 225               		.cfi_def_cfa_offset 8
 226               		.cfi_offset 31, -7
 227               	/* prologue: Signal */
 228               	/* frame size = 0 */
 229               	/* stack size = 7 */
 230               	.L__stack_usage = 7
 432:src/uart.c    ****     unsigned char tmptail;
 433:src/uart.c    **** 
 434:src/uart.c    ****     
 435:src/uart.c    ****     if ( UART_TxHead != UART_TxTail) {
 231               		.loc 1 435 0
 232 00e0 9091 0000 		lds r25,UART_TxHead
 233 00e4 8091 0000 		lds r24,UART_TxTail
 234 00e8 9817      		cp r25,r24
 235 00ea 01F0      		breq .L10
 436:src/uart.c    ****         /* calculate and store new buffer index */
 437:src/uart.c    ****         tmptail = (UART_TxTail + 1) & UART_TX_BUFFER_MASK;
 236               		.loc 1 437 0
 237 00ec E091 0000 		lds r30,UART_TxTail
 238 00f0 EF5F      		subi r30,lo8(-(1))
 239 00f2 EF71      		andi r30,lo8(31)
 240               	.LVL14:
 438:src/uart.c    ****         UART_TxTail = tmptail;
 241               		.loc 1 438 0
 242 00f4 E093 0000 		sts UART_TxTail,r30
 439:src/uart.c    ****         /* get one byte from buffer and write it to UART */
 440:src/uart.c    ****         UART0_DATA = UART_TxBuf[tmptail];  /* start transmission */
 243               		.loc 1 440 0
 244 00f8 F0E0      		ldi r31,0
 245 00fa E050      		subi r30,lo8(-(UART_TxBuf))
 246 00fc F040      		sbci r31,hi8(-(UART_TxBuf))
 247               	.LVL15:
 248 00fe 8081      		ld r24,Z
 249 0100 8093 C600 		sts 198,r24
 250               	.LVL16:
 251 0104 00C0      		rjmp .L9
 252               	.L10:
 441:src/uart.c    ****     }else{
 442:src/uart.c    ****         /* tx buffer empty, disable UDRE interrupt */
 443:src/uart.c    ****         UART0_CONTROL &= ~_BV(UART0_UDRIE);
 253               		.loc 1 443 0
 254 0106 8091 C100 		lds r24,193
 255 010a 8F7D      		andi r24,lo8(-33)
 256 010c 8093 C100 		sts 193,r24
 257               	.L9:
 258               	/* epilogue start */
 444:src/uart.c    ****     }
 445:src/uart.c    **** }
 259               		.loc 1 445 0
 260 0110 FF91      		pop r31
 261 0112 EF91      		pop r30
 262 0114 9F91      		pop r25
 263 0116 8F91      		pop r24
 264 0118 0F90      		pop r0
 265 011a 0FBE      		out __SREG__,r0
 266 011c 0F90      		pop r0
 267 011e 1F90      		pop r1
 268 0120 1895      		reti
 269               		.cfi_endproc
 270               	.LFE3:
 272               	.global	uart_init
 274               	uart_init:
 275               	.LFB4:
 446:src/uart.c    **** 
 447:src/uart.c    **** 
 448:src/uart.c    **** /*************************************************************************
 449:src/uart.c    **** Function: uart_init()
 450:src/uart.c    **** Purpose:  initialize UART and set baudrate
 451:src/uart.c    **** Input:    baudrate using macro UART_BAUD_SELECT()
 452:src/uart.c    **** Returns:  none
 453:src/uart.c    **** **************************************************************************/
 454:src/uart.c    **** void uart_init(unsigned int baudrate)
 455:src/uart.c    **** {
 276               		.loc 1 455 0
 277               		.cfi_startproc
 278               	.LVL17:
 279               	/* prologue: function */
 280               	/* frame size = 0 */
 281               	/* stack size = 0 */
 282               	.L__stack_usage = 0
 456:src/uart.c    ****     UART_TxHead = 0;
 283               		.loc 1 456 0
 284 0122 1092 0000 		sts UART_TxHead,__zero_reg__
 457:src/uart.c    ****     UART_TxTail = 0;
 285               		.loc 1 457 0
 286 0126 1092 0000 		sts UART_TxTail,__zero_reg__
 458:src/uart.c    ****     UART_RxHead = 0;
 287               		.loc 1 458 0
 288 012a 1092 0000 		sts UART_RxHead,__zero_reg__
 459:src/uart.c    ****     UART_RxTail = 0;
 289               		.loc 1 459 0
 290 012e 1092 0000 		sts UART_RxTail,__zero_reg__
 460:src/uart.c    **** 
 461:src/uart.c    **** #ifdef UART_TEST
 462:src/uart.c    **** #ifndef UART0_BIT_U2X
 463:src/uart.c    **** #warning "UART0_BIT_U2X not defined"
 464:src/uart.c    **** #endif
 465:src/uart.c    **** #ifndef UART0_UBRRH
 466:src/uart.c    **** #warning "UART0_UBRRH not defined"
 467:src/uart.c    **** #endif
 468:src/uart.c    **** #ifndef UART0_CONTROLC
 469:src/uart.c    **** #warning "UART0_CONTROLC not defined"
 470:src/uart.c    **** #endif
 471:src/uart.c    **** #if defined(URSEL) || defined(URSEL0)
 472:src/uart.c    **** #ifndef UART0_BIT_URSEL
 473:src/uart.c    **** #warning "UART0_BIT_URSEL not defined"
 474:src/uart.c    **** #endif
 475:src/uart.c    **** #endif
 476:src/uart.c    **** #endif
 477:src/uart.c    **** 
 478:src/uart.c    ****     /* Set baud rate */
 479:src/uart.c    ****     if ( baudrate & 0x8000 )
 291               		.loc 1 479 0
 292 0132 97FF      		sbrs r25,7
 293 0134 00C0      		rjmp .L13
 480:src/uart.c    ****     {
 481:src/uart.c    ****         #if UART0_BIT_U2X
 482:src/uart.c    ****         UART0_STATUS = (1<<UART0_BIT_U2X);  //Enable 2x speed 
 294               		.loc 1 482 0
 295 0136 22E0      		ldi r18,lo8(2)
 296 0138 2093 C000 		sts 192,r18
 297               	.L13:
 483:src/uart.c    ****         #endif
 484:src/uart.c    ****     } 
 485:src/uart.c    ****     #if defined(UART0_UBRRH)
 486:src/uart.c    ****     UART0_UBRRH = (unsigned char)((baudrate>>8)&0x80) ;
 298               		.loc 1 486 0
 299 013c 9078      		andi r25,lo8(-128)
 300 013e 9093 C500 		sts 197,r25
 487:src/uart.c    ****     #endif    
 488:src/uart.c    ****     UART0_UBRRL = (unsigned char) (baudrate&0x00FF);
 301               		.loc 1 488 0
 302 0142 8093 C400 		sts 196,r24
 489:src/uart.c    ****       
 490:src/uart.c    ****     /* Enable USART receiver and transmitter and receive complete interrupt */
 491:src/uart.c    ****     UART0_CONTROL = _BV(UART0_BIT_RXCIE)|(1<<UART0_BIT_RXEN)|(1<<UART0_BIT_TXEN);
 303               		.loc 1 491 0
 304 0146 88E9      		ldi r24,lo8(-104)
 305               	.LVL18:
 306 0148 8093 C100 		sts 193,r24
 492:src/uart.c    ****     
 493:src/uart.c    ****     /* Set frame format: asynchronous, 8data, no parity, 1stop bit */
 494:src/uart.c    ****     #ifdef UART0_CONTROLC
 495:src/uart.c    ****     #ifdef UART0_BIT_URSEL
 496:src/uart.c    ****     UART0_CONTROLC = (1<<UART0_BIT_URSEL)|(1<<UART0_BIT_UCSZ1)|(1<<UART0_BIT_UCSZ0);
 497:src/uart.c    ****     #else
 498:src/uart.c    ****     UART0_CONTROLC = (1<<UART0_BIT_UCSZ1)|(1<<UART0_BIT_UCSZ0);
 307               		.loc 1 498 0
 308 014c 86E0      		ldi r24,lo8(6)
 309 014e 8093 C200 		sts 194,r24
 310 0152 0895      		ret
 311               		.cfi_endproc
 312               	.LFE4:
 314               	.global	uart_getc
 316               	uart_getc:
 317               	.LFB5:
 499:src/uart.c    ****     #endif 
 500:src/uart.c    ****     #endif
 501:src/uart.c    **** 
 502:src/uart.c    **** }/* uart_init */
 503:src/uart.c    **** 
 504:src/uart.c    **** 
 505:src/uart.c    **** /*************************************************************************
 506:src/uart.c    **** Function: uart_getc()
 507:src/uart.c    **** Purpose:  return byte from ringbuffer  
 508:src/uart.c    **** Returns:  lower byte:  received byte from ringbuffer
 509:src/uart.c    ****           higher byte: last receive error
 510:src/uart.c    **** **************************************************************************/
 511:src/uart.c    **** unsigned int uart_getc(void)
 512:src/uart.c    **** {    
 318               		.loc 1 512 0
 319               		.cfi_startproc
 320               	/* prologue: function */
 321               	/* frame size = 0 */
 322               	/* stack size = 0 */
 323               	.L__stack_usage = 0
 513:src/uart.c    ****     unsigned char tmptail;
 514:src/uart.c    ****     unsigned char data;
 515:src/uart.c    ****     unsigned char lastRxError;
 516:src/uart.c    **** 
 517:src/uart.c    **** 
 518:src/uart.c    ****     if ( UART_RxHead == UART_RxTail ) {
 324               		.loc 1 518 0
 325 0154 9091 0000 		lds r25,UART_RxHead
 326 0158 8091 0000 		lds r24,UART_RxTail
 327 015c 9817      		cp r25,r24
 328 015e 01F0      		breq .L16
 519:src/uart.c    ****         return UART_NO_DATA;   /* no data available */
 520:src/uart.c    ****     }
 521:src/uart.c    ****     
 522:src/uart.c    ****     /* calculate buffer index */
 523:src/uart.c    ****     tmptail = (UART_RxTail + 1) & UART_RX_BUFFER_MASK;
 329               		.loc 1 523 0
 330 0160 9091 0000 		lds r25,UART_RxTail
 331 0164 9F5F      		subi r25,lo8(-(1))
 332 0166 9F71      		andi r25,lo8(31)
 333               	.LVL19:
 524:src/uart.c    ****     
 525:src/uart.c    ****     /* get data from receive buffer */
 526:src/uart.c    ****     data = UART_RxBuf[tmptail];
 334               		.loc 1 526 0
 335 0168 E92F      		mov r30,r25
 336 016a F0E0      		ldi r31,0
 337 016c E050      		subi r30,lo8(-(UART_RxBuf))
 338 016e F040      		sbci r31,hi8(-(UART_RxBuf))
 339 0170 2081      		ld r18,Z
 340               	.LVL20:
 527:src/uart.c    ****     lastRxError = UART_LastRxError;
 341               		.loc 1 527 0
 342 0172 8091 0000 		lds r24,UART_LastRxError
 343               	.LVL21:
 528:src/uart.c    ****     
 529:src/uart.c    ****     /* store buffer index */
 530:src/uart.c    ****     UART_RxTail = tmptail; 
 344               		.loc 1 530 0
 345 0176 9093 0000 		sts UART_RxTail,r25
 531:src/uart.c    ****     
 532:src/uart.c    ****     UART_LastRxError = 0;
 346               		.loc 1 532 0
 347 017a 1092 0000 		sts UART_LastRxError,__zero_reg__
 533:src/uart.c    ****     return (lastRxError << 8) + data;
 348               		.loc 1 533 0
 349 017e 90E0      		ldi r25,0
 350               	.LVL22:
 351 0180 982F      		mov r25,r24
 352 0182 8827      		clr r24
 353               	.LVL23:
 354 0184 820F      		add r24,r18
 355 0186 911D      		adc r25,__zero_reg__
 356 0188 0895      		ret
 357               	.LVL24:
 358               	.L16:
 519:src/uart.c    ****         return UART_NO_DATA;   /* no data available */
 359               		.loc 1 519 0
 360 018a 80E0      		ldi r24,0
 361 018c 91E0      		ldi r25,lo8(1)
 534:src/uart.c    **** 
 535:src/uart.c    **** }/* uart_getc */
 362               		.loc 1 535 0
 363 018e 0895      		ret
 364               		.cfi_endproc
 365               	.LFE5:
 367               	.global	uart_putc
 369               	uart_putc:
 370               	.LFB6:
 536:src/uart.c    **** 
 537:src/uart.c    **** 
 538:src/uart.c    **** /*************************************************************************
 539:src/uart.c    **** Function: uart_putc()
 540:src/uart.c    **** Purpose:  write byte to ringbuffer for transmitting via UART
 541:src/uart.c    **** Input:    byte to be transmitted
 542:src/uart.c    **** Returns:  none          
 543:src/uart.c    **** **************************************************************************/
 544:src/uart.c    **** void uart_putc(unsigned char data)
 545:src/uart.c    **** {
 371               		.loc 1 545 0
 372               		.cfi_startproc
 373               	.LVL25:
 374               	/* prologue: function */
 375               	/* frame size = 0 */
 376               	/* stack size = 0 */
 377               	.L__stack_usage = 0
 546:src/uart.c    ****     unsigned char tmphead;
 547:src/uart.c    **** 
 548:src/uart.c    ****     
 549:src/uart.c    ****     tmphead  = (UART_TxHead + 1) & UART_TX_BUFFER_MASK;
 378               		.loc 1 549 0
 379 0190 9091 0000 		lds r25,UART_TxHead
 380 0194 9F5F      		subi r25,lo8(-(1))
 381 0196 9F71      		andi r25,lo8(31)
 382               	.LVL26:
 383               	.L19:
 550:src/uart.c    ****     
 551:src/uart.c    ****     while ( tmphead == UART_TxTail ){
 384               		.loc 1 551 0 discriminator 1
 385 0198 2091 0000 		lds r18,UART_TxTail
 386 019c 9217      		cp r25,r18
 387 019e 01F0      		breq .L19
 552:src/uart.c    ****         ;/* wait for free space in buffer */
 553:src/uart.c    ****     }
 554:src/uart.c    ****     
 555:src/uart.c    ****     UART_TxBuf[tmphead] = data;
 388               		.loc 1 555 0
 389 01a0 E92F      		mov r30,r25
 390 01a2 F0E0      		ldi r31,0
 391 01a4 E050      		subi r30,lo8(-(UART_TxBuf))
 392 01a6 F040      		sbci r31,hi8(-(UART_TxBuf))
 393 01a8 8083      		st Z,r24
 556:src/uart.c    ****     UART_TxHead = tmphead;
 394               		.loc 1 556 0
 395 01aa 9093 0000 		sts UART_TxHead,r25
 557:src/uart.c    **** 
 558:src/uart.c    ****     /* enable UDRE interrupt */
 559:src/uart.c    ****     UART0_CONTROL    |= _BV(UART0_UDRIE);
 396               		.loc 1 559 0
 397 01ae 8091 C100 		lds r24,193
 398               	.LVL27:
 399 01b2 8062      		ori r24,lo8(32)
 400 01b4 8093 C100 		sts 193,r24
 401 01b8 0895      		ret
 402               		.cfi_endproc
 403               	.LFE6:
 405               	.global	uart_puts
 407               	uart_puts:
 408               	.LFB7:
 560:src/uart.c    **** 
 561:src/uart.c    **** }/* uart_putc */
 562:src/uart.c    **** 
 563:src/uart.c    **** 
 564:src/uart.c    **** /*************************************************************************
 565:src/uart.c    **** Function: uart_puts()
 566:src/uart.c    **** Purpose:  transmit string to UART
 567:src/uart.c    **** Input:    string to be transmitted
 568:src/uart.c    **** Returns:  none          
 569:src/uart.c    **** **************************************************************************/
 570:src/uart.c    **** void uart_puts(const char *s )
 571:src/uart.c    **** {
 409               		.loc 1 571 0
 410               		.cfi_startproc
 411               	.LVL28:
 412 01ba CF93      		push r28
 413               	.LCFI21:
 414               		.cfi_def_cfa_offset 3
 415               		.cfi_offset 28, -2
 416 01bc DF93      		push r29
 417               	.LCFI22:
 418               		.cfi_def_cfa_offset 4
 419               		.cfi_offset 29, -3
 420               	/* prologue: function */
 421               	/* frame size = 0 */
 422               	/* stack size = 2 */
 423               	.L__stack_usage = 2
 424 01be EC01      		movw r28,r24
 425               	.LVL29:
 426               	.L21:
 572:src/uart.c    ****     while (*s) 
 427               		.loc 1 572 0 discriminator 1
 428 01c0 8991      		ld r24,Y+
 429               	.LVL30:
 430 01c2 8823      		tst r24
 431 01c4 01F0      		breq .L23
 432               	.LVL31:
 573:src/uart.c    ****       uart_putc(*s++);
 433               		.loc 1 573 0
 434 01c6 0E94 0000 		call uart_putc
 435               	.LVL32:
 436 01ca 00C0      		rjmp .L21
 437               	.LVL33:
 438               	.L23:
 439               	/* epilogue start */
 574:src/uart.c    **** 
 575:src/uart.c    **** }/* uart_puts */
 440               		.loc 1 575 0
 441 01cc DF91      		pop r29
 442 01ce CF91      		pop r28
 443               	.LVL34:
 444 01d0 0895      		ret
 445               		.cfi_endproc
 446               	.LFE7:
 448               	.global	uart_puts_p
 450               	uart_puts_p:
 451               	.LFB8:
 576:src/uart.c    **** 
 577:src/uart.c    **** 
 578:src/uart.c    **** /*************************************************************************
 579:src/uart.c    **** Function: uart_puts_p()
 580:src/uart.c    **** Purpose:  transmit string from program memory to UART
 581:src/uart.c    **** Input:    program memory string to be transmitted
 582:src/uart.c    **** Returns:  none
 583:src/uart.c    **** **************************************************************************/
 584:src/uart.c    **** void uart_puts_p(const char *progmem_s )
 585:src/uart.c    **** {
 452               		.loc 1 585 0
 453               		.cfi_startproc
 454               	.LVL35:
 455 01d2 CF93      		push r28
 456               	.LCFI23:
 457               		.cfi_def_cfa_offset 3
 458               		.cfi_offset 28, -2
 459 01d4 DF93      		push r29
 460               	.LCFI24:
 461               		.cfi_def_cfa_offset 4
 462               		.cfi_offset 29, -3
 463               	/* prologue: function */
 464               	/* frame size = 0 */
 465               	/* stack size = 2 */
 466               	.L__stack_usage = 2
 467 01d6 FC01      		movw r30,r24
 468               	.LVL36:
 469               	.L25:
 470               	.LBB3:
 586:src/uart.c    ****     register char c;
 587:src/uart.c    ****     
 588:src/uart.c    ****     while ( (c = pgm_read_byte(progmem_s++)) ) 
 471               		.loc 1 588 0 discriminator 1
 472               	/* #APP */
 473               	 ;  588 "src/uart.c" 1
 474 01d8 8491      		lpm r24, Z
 475               		
 476               	 ;  0 "" 2
 477               	.LVL37:
 478               	/* #NOAPP */
 479 01da EF01      		movw r28,r30
 480 01dc 2196      		adiw r28,1
 481               	.LVL38:
 482               	.LBE3:
 483 01de 8823      		tst r24
 484 01e0 01F0      		breq .L27
 589:src/uart.c    ****       uart_putc(c);
 485               		.loc 1 589 0
 486 01e2 0E94 0000 		call uart_putc
 487               	.LVL39:
 488 01e6 FE01      		movw r30,r28
 489 01e8 00C0      		rjmp .L25
 490               	.LVL40:
 491               	.L27:
 492               	/* epilogue start */
 590:src/uart.c    **** 
 591:src/uart.c    **** }/* uart_puts_p */
 493               		.loc 1 591 0
 494 01ea DF91      		pop r29
 495 01ec CF91      		pop r28
 496               	.LVL41:
 497 01ee 0895      		ret
 498               		.cfi_endproc
 499               	.LFE8:
 501               		.local	UART_LastRxError
 502               		.comm	UART_LastRxError,1,1
 503               		.local	UART_RxTail
 504               		.comm	UART_RxTail,1,1
 505               		.local	UART_RxHead
 506               		.comm	UART_RxHead,1,1
 507               		.local	UART_TxTail
 508               		.comm	UART_TxTail,1,1
 509               		.local	UART_TxHead
 510               		.comm	UART_TxHead,1,1
 511               		.local	UART_RxBuf
 512               		.comm	UART_RxBuf,32,1
 513               		.local	UART_TxBuf
 514               		.comm	UART_TxBuf,32,1
 515               	.Letext0:
 516               		.file 2 "/usr/lib/avr/include/stdint.h"
 517               		.file 3 "/usr/lib/avr/include/stdlib.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 uart.c
     /tmp/cc1TGVaq.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc1TGVaq.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc1TGVaq.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc1TGVaq.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc1TGVaq.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc1TGVaq.s:12     .text:0000000000000000 __vector_18
     /tmp/cc1TGVaq.s:504    .bss:0000000000000002 UART_RxHead
     /tmp/cc1TGVaq.s:502    .bss:0000000000000001 UART_RxTail
     /tmp/cc1TGVaq.s:510    .bss:0000000000000005 UART_RxBuf
                             .bss:0000000000000000 UART_LastRxError
     /tmp/cc1TGVaq.s:196    .text:00000000000000ce __vector_19
     /tmp/cc1TGVaq.s:508    .bss:0000000000000004 UART_TxHead
     /tmp/cc1TGVaq.s:506    .bss:0000000000000003 UART_TxTail
     /tmp/cc1TGVaq.s:512    .bss:0000000000000025 UART_TxBuf
     /tmp/cc1TGVaq.s:274    .text:0000000000000122 uart_init
     /tmp/cc1TGVaq.s:316    .text:0000000000000154 uart_getc
     /tmp/cc1TGVaq.s:369    .text:0000000000000190 uart_putc
     /tmp/cc1TGVaq.s:407    .text:00000000000001ba uart_puts
     /tmp/cc1TGVaq.s:450    .text:00000000000001d2 uart_puts_p

UNDEFINED SYMBOLS
i
line
atof
desired_rpm
__do_clear_bss
